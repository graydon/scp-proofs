#lang ivy1.7

include sort
include node
include network
include assertion

# Ivy checks that the following invariants always hold if we start with the initialization state
# (i.e., `after init`) and continuously apply the exported actions below.

invariant [heard_vote_implies_voted] assertion.heard_vote_implies_voted
invariant [heard_accept_implies_accepted] assertion.heard_accept_implies_accepted
invariant [accept_means_at_least_one_vote] assertion.accept_means_at_least_one_vote
invariant [confirm_same_after_sufficient_messages] assertion.confirm_same_after_sufficient_messages


# We need a bunch of auxiliary invariants for the prover to avoid spurious CTIs

invariant [heard_all_accept_implies_confirmed]
    forall N1, V. (forall N2. node.heard_accept(N1,N2, V)) -> node.confirmed(N1, V)

invariant [confirmed_implies_all_accepted]
    forall N, V. (node.confirmed(N,V) -> forall M . node.accepted(M,V))

invariant [confirmed_implies_some_heard_accept]
    forall N, V. node.confirmed(N,V) -> exists N2. node.heard_accept(N,N2,V)

invariant [accept_implies_some_voted]
    (exists N1, V1 . node.accepted(N1, V1)) -> (exists N2, V2 . node.voted(N2, V2))

invariant [no_multi_vote]
    forall N, V1, V2 . node.voted(N, V1) & node.voted(N, V2) -> V1 = V2

invariant [no_multi_accept]
    forall N, V1, V2 . node.accepted(N, V1) & node.accepted(N, V2) -> V1 = V2

invariant [confirm_implies_accepted]
    forall N, V . node.confirmed(N, V) -> node.accepted(N, V)


export network.deliver_vote
export network.deliver_accept
export node.vote
