#lang ivy1.6

include order

type value
type node
type nset # sets of nodes
type ballot

trusted isolate ordering_assms = {
    instantiate totally_ordered(ballot)
    instantiate totally_ordered(value)     
}

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

# intact nodes are intertwined
axiom intact(N) -> intertwined(N)
# intertwined nodes are well-behaved
axiom intertwined(N) -> well_behaved(N)

relation member(N:node, S:nset)
relation is_quorum(Q:nset)

# quorum intersection
axiom (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)
axiom (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)

relation blocks_slices(S:nset, N:node)
# if set R blocks an intact node then R contains an intact node
axiom (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)

# the set of all intact nodes is a quorum
axiom exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)

object protocol = {
    
    relation voted_prepared(N:node, B:ballot, V:value)
    relation accepted_prepared(N:node, B:ballot, V:value)
    relation confirmed_prepared(N:node, B:ballot, V:value)
    relation voted_committed(N:node, B:ballot, V:value)
    relation accepted_committed(N:node, B:ballot, V:value)
    relation confirmed_committed(N:node, B:ballot, V:value)
    relation nomination_output(N:node, V:value)
    relation timer_armed(N:node)
    relation started(N:node, B:ballot)
    relation left_ballot(N:node, B:ballot)

    # messages received
    relation received_vote_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_vote_commit(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_commit(N1:node, N2:node, B:ballot, V:value)

    object actions = {

        after init {
            voted_prepared(N,B,V) := false;
            accepted_prepared(N,B,V) := false;
            confirmed_prepared(N,B,V) := false;
            voted_committed(N,B,V) := false;
            accepted_committed(N,B,V) := false;
            confirmed_committed(N,B,V) := false;
            nomination_output(N,X) := false;
            left_ballot(N,B) := false;
            started(N,B) := false;
            timer_armed(N) := false;
            received_vote_prepare(N1,N2,B,V) := false;
            received_vote_commit(N1,N2,B,V) := false;
            received_accept_prepare(N1,N2,B,V) := false;
            received_accept_commit(N1,N2,B,V) := false;
            
            # here we add all intact nodes to the inital footpring; there are finitely many intact nodes, thus this is okay.
            l2s_d(N:node) := well_behaved(N); 
        }

        action assume_safety_properties = {
            # assumes safety properties proved in SCP-safety.ivy.
            assume ~(well_behaved(N) & left_ballot(N,B) & B2 < B & ~left_ballot(N,B2));
            assume ~(well_behaved(N) & started(N,B) & B0 < B & ~left_ballot(N,B0));
            assume well_behaved(N) & received_accept_prepare(N,N2,B,V) & well_behaved(N2) -> accepted_prepared(N2,B,V);
            assume well_behaved(N) & voted_prepared(N,B,V) -> started(N,B);
            assume intact(n2) & (forall N. intact(N) -> received_accept_prepare(n2,N,b1,v)) -> confirmed_prepared(n2,b1,v);
            assume intact(N1) & blocks_slices(S,N1) & (forall N2. member(N2,S) -> received_accept_prepare(N1,N2,b1,v)) & (forall B,V . B <= b1  & accepted_committed(N1,B,V) -> V = v) -> accepted_prepared(N1,b1,v);
            assume intact(N1) & confirmed_prepared(N1,B1,V1) & intact(N2) & B2 <= B1 & accepted_committed(N2,B2,V2) -> V1 = V2;

            # The cascade theorem: if a set of nodes including a quorum of an intact node accepts, then either all intact accept or there is an intact node blocked by a subset of intact that accepts:
            assume is_quorum(q0) & (exists N0 . intact(N0) & member(N0,q0)) & (forall N . intact(N) & member(N,q0) -> accepted_prepared(N,b1,v)) -> ((forall N1 . intact(N1) -> accepted_prepared(N1,b1,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b1,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b1,v)))));
            
        }
        
        action byzantine_step = {
            call assume_safety_properties();
            
            voted_prepared(N,B,X) := *;
            assume ~(well_behaved(N) & (voted_prepared(N,B,X) ~= old voted_prepared(N,B,X)));
            accepted_prepared(N,B,X) := *;
            assume ~(well_behaved(N) & (accepted_prepared(N,B,X) ~= old accepted_prepared(N,B,X)));
            voted_committed(N,B,X) := *;
            assume ~(well_behaved(N) & (voted_committed(N,B,X) ~= old voted_committed(N,B,X)));
            accepted_committed(N,B,X) := *;
            assume ~(well_behaved(N) & (accepted_committed(N,B,X) ~= old accepted_committed(N,B,X)));
            confirmed_prepared(N,B,V) := *;
            assume ~(well_behaved(N) & (confirmed_prepared(N,B,X) ~= old confirmed_prepared(N,B,X)));
            confirmed_committed(N,B,V) := *;
            assume ~(well_behaved(N) & (confirmed_committed(N,B,X) ~= old confirmed_committed(N,B,X)));
            nomination_output(N,V) := *;
            assume ~(well_behaved(N) & (nomination_output(N,X) ~= old nomination_output(N,X)));
            started(N,B) := *;
            assume ~(well_behaved(N) & (started(N,B) ~= old started(N,B)));
            left_ballot(N,B) := *;
            assume ~(well_behaved(N) & (left_ballot(N,B) ~= old left_ballot(N,B)));
            timer_armed(N) := *;
            assume ~(well_behaved(N) & (timer_armed(N) ~= old timer_armed(Nv)));
            received_vote_prepare(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_vote_prepare(N1,N2,B,V) ~= old received_vote_prepare(N1,N2,B,V)));
            received_accept_prepare(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_accept_prepare(N1,N2,B,V) ~= old received_accept_prepare(N1,N2,B,V)));
            received_vote_commit(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_vote_commit(N1,N2,B,V) ~= old received_vote_commit(N1,N2,B,V)));
            received_accept_commit(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_accept_commit(N1,N2,B,V) ~= old received_accept_commit(N1,N2,B,V)));
            
            call assume_safety_properties();
        }
        
        action timeout(n:node) = {
            call assume_safety_properties();
            
            assume timer_armed(n);
            local cur:ballot, suc:ballot {
                assume ~left_ballot(n, cur) & started(n, cur);
                assume  ~(cur < B & B < suc); # suc is the next ballot
                call change_ballot(n, suc);
            };
            
            call assume_safety_properties();
        }

        action join_ballot(n:node, b:ballot) = {
            call assume_safety_properties();
            
            assume ~left_ballot(n,b) & ~started(n,b);
            assume exists S . blocks_slices(S,n) & forall N . member(N,S) -> exists B,V . B >= b & (
                received_vote_prepare(n,N,B,V) | received_vote_commit(n,N,B,V) | received_accept_prepare(n,N,B,V) | received_accept_commit(n,N,B,V) );
            timer_armed(n) := false;
            call change_ballot(n,b);
            
            call assume_safety_properties();
        }

        action arm_timer(n:node) = {
            call assume_safety_properties();
            
            local cur:ballot {
                assume ~left_ballot(n, cur) & started(n, cur);
                assume exists Q . is_quorum(Q) & member(n,Q) & forall N . member(N, Q) -> exists V .
                    received_vote_prepare(n,N,cur,V) | received_vote_commit(n,N,cur,V) | received_accept_prepare(n,N,cur,V) | received_accept_commit(n,N,cur,V);
                timer_armed(n) := true;
            };
            
            call assume_safety_properties();
        }
        
        action change_ballot(n:node, b:ballot) = {
            call assume_safety_properties();
            
            assume ~left_ballot(n, b) & ~started(n, b);
            left_ballot(n,B) := B < b;
            started(n,b) := true;
            timer_armed(n) := false;
            # now vote prepared:
            local bmax:ballot, vmax:value {
                # use the highest confirmed prepared value or, if none exists, the nomination output:
                # TODO we probably do not need the ordering on values: there should be a unique highest if intertwined
                assume
                    ((forall B,V . B < b -> ~confirmed_prepared(n,B,V)) & nomination_output(n,vmax))
                    | (bmax < b & confirmed_prepared(n,bmax,vmax) & (forall B,V . B < b & confirmed_prepared(n,B,V) -> (B < bmax | (B = bmax & V <= vmax))));
                # NOTE at this point it is not possible that we contradict a non-overruled vote to commit because a vote to commit must have been prepared first.
                voted_prepared(n, b, vmax) := true; # Note we vote to prepare only once per ballot.
            };

            call assume_safety_properties();            
        }
        
        # n1 receives a new vote to prepare (b,v); it checks whether quorum threshold is reached and, if so, accepts (b,v) as prepared unless it accepted a different, earlier value as committed.
        action receive_vote_prepare(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();
            
            assume started(na,b);
            assume voted_prepared(nb,b,v);
            received_vote_prepare(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) &
               (forall B,V . ~(accepted_committed(na,B,V) & B <= b & V ~= v))  # not accepted anything contradictory
            {
                accepted_prepared(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }

        action receive_vote_commit(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();            

            assume voted_committed(nb,b,v);
            received_vote_commit(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) &
               (forall B,V . ~(accepted_prepared(na,B,V) & b <= B & V ~= v)) & # not accepted anything contradictory
               (forall V . ~accepted_committed(na,b,V)) & # do not accept commit twice
               (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };

            call assume_safety_properties();
        }

        action receive_accept_prepare(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();

            assume accepted_prepared(nb,b,v);
            received_accept_prepare(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_prepare(na,N,b,v) {
                confirmed_prepared(na,b,v) := true; # we must confirm prepared even if we left the ballot because that's used to pick the value to prepare in higher ballots.
                if ~left_ballot(na,b) & started(na,b) { # we do not vote if b is not the current ballot.
                    voted_committed(na,b,v) := true;
                };
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) & (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) |
                   (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_prepare(na,N,b,v)))) &
               (forall B,V . ~(accepted_committed(na,B,V) & B <= b & V ~= v)) # not accepted anything contradictory
            {
                accepted_prepared(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }

        action receive_accept_commit(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();

            assume accepted_committed(nb,b,v);
            received_accept_commit(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_commit(na,N,b,v) {
                confirmed_committed(na,b,v) := true;
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) &
                    (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) |
                (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_commit(na,N,b,v)))) &
                (forall B,V . ~(accepted_prepared(na,B,V) & b <= B & V ~= v)) & # not accepted anything contradictory
                (forall V . ~accepted_committed(na,b,V)) & # do not accept twice.
                (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }
         
        export receive_vote_prepare
        export byzantine_step # OKAY
        export receive_vote_commit
        export receive_accept_prepare
        export receive_accept_commit
        export change_ballot
        export timeout
        export join_ballot
        export arm_timer

    }

    individual b0:ballot
    
    # prophecy witnesses:
    individual n1:node
    individual n2:node
    individual b1:ballot
    individual v:value
    individual q0:nset
    
    isolate liveness = {

        # Here we prove that by the end of a "good" ballot, all intact nodes have confirmed prepared the same things. This relies on the cascade theorem and also on the fact that once an intact node accepts something prepared, it can never be contradicted by other intact nodes anymore. This last property is crucial since nodes do not accept contradictory statements and therefore cascading may not occur.
        # Formally, we assume that the intact node n1 violates this property and we derive a contradiction.
        
        object spec = {
            temporal property (
                # Well-behaved nodes are synchronous in b0 (there is no requirement to be up and send messages, but a message sent must be delivered to all).
                # TODO this requirement could be weakened to only require that intact nodes receive all messages sent by well-behaved nodes that are in their quorums.
                (forall N1,N2,N3,V,B . well_behaved(N1) & well_behaved(N2) & well_behaved(N3) & B <= b0 -> globally ~(left_ballot(N3,b0) & accepted_prepared(N2,B,V) & ~received_accept_prepare(N1,N2,B,V))) &
                # prophecy witness q0 (TODO here we take a shortcut whose soundness depends on the accepted_prepared relation being monotonic):
                is_quorum(q0) & (exists N . intact(N) & member(N, q0)) & (globally ((exists Q . forall N . member(N,Q) & well_behaved(N) -> accepted_prepared(N,b1,v)) -> (forall N . member(N,q0) & well_behaved(N) -> accepted_prepared(N,b1,v)))) &
                b1 <= b0 & intact(n1) & intact(n2) & (eventually (confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)))
            ) -> false
        }


        object impl = {

            # The proof:
            # Once confirmed_prepared(n1,b1,v) holds, the quorum q0 has unanimously accepted (b1,v) as prepared. Hence, by the cascade theorem, either (a) all intact nodes accepted (b1,v) as prepared, or (b) there is an intact node n that has not accepted (b1,v) as prepared and that is blocked by the intact nodes that have. Note that (c) since b0 is a good ballot and n2 already left b0, all intact nodes received all accept-prepared messages addressed to them. In case (a), all intact nodes received accept-prepare (b1,v) from a quorum and confirmed (b1,v) as preapred; thus ~confirmed_prepared(n2,b1,v) leads to a contradiction. In case (b), node n must be waiting to receive an accept-prepare messages from another intact node, or otherwise it would have accepted (b1,v) as prepared. However, by (1) it must also have received them all; thus we reach a contradiction too.
            
            # WARNING: due to quantifier alternation cycles, this takes several hours to check on a recent laptop. The verification varies significantly depending on the random seed passed to Z3.
         
            # properties of the initial footprint:
            conjecture well_behaved(N) -> l2s_d(N)
            conjecture l2s_d(n1) & l2s_d(n2) & l2s_d(b1) & l2s_d(v) & l2s_d(b0)

            conjecture  b1 <= b0 & intact(n1) & intact(n2)
           
            # waiting can only cease when the condition is true:
            conjecture ~globally ~(confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))
            conjecture ($l2s_w . confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)) | (confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))
            conjecture ($l2s_w . confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)) -> ~(confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))
            
            # the q0 witness:
            conjecture is_quorum(q0) & (exists N . intact(N) & member(N, q0)) & (globally ((exists Q . forall N . member(N,Q) & well_behaved(N) -> accepted_prepared(N,b1,v)) -> (forall N . member(N,q0) & well_behaved(N) -> accepted_prepared(N,b1,v))))
            conjecture confirmed_prepared(n1,b1,v) -> (forall N . member(N,q0) & intact(N) -> accepted_prepared(N,b1,v)) & is_quorum(q0) & (exists N2 . intact(N2) & member(N2,q0))
            
            # well-behaved nodes are synchronous in b0:
            conjecture well_behaved(N1) & well_behaved(N2) & well_behaved(N3) & B <= b0 -> globally ~(left_ballot(N3,b0) & accepted_prepared(N2,B,V) & ~received_accept_prepare(N1,N2,B,V))
            
            conjecture ~(confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))

            conjecture ($l2s_w . confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))

            conjecture l2s_waiting # we never reach the freeze point.
            
            # those three should not be needed... just for debugging: all OKAY
            # conjecture left_ballot(n2,b0) & intact(N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b1,v))) -> (forall N3 . member(N3,S) -> received_accept_prepare(N2,N3,b1,v))
            # conjecture intact(N2) &  blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & received_accept_prepare(N2,N3,b1,v))) & confirmed_prepared(n1,b1,v) -> accepted_prepared(N2,b1,v)
            # conjecture (confirmed_prepared(n1,b1,v) & left_ballot(n2,b0)) -> (confirmed_prepared(n2,b1,v) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b1,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b1,v)))))

        }
        
    } with actions, ordering_assms
}
