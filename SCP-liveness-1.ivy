#lang ivy1.6

# Here we prove that by the end of a "good" ballot, all intact nodes have confirmed prepared the same things.

include order

type value
type node
type nset # sets of nodes
type ballot

trusted isolate ordering_assms = {
    instantiate totally_ordered(ballot)
    #instantiate totally_ordered(value)     
}

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

# intact nodes are intertwined
axiom intact(N) -> intertwined(N)
# intertwined nodes are well-behaved
axiom intertwined(N) -> well_behaved(N)

relation member(N:node, S:nset)
relation is_quorum(Q:nset)

# quorum intersection
# QAG edge nset -> node
trusted isolate qi_intertwined = {
    property (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)
}
trusted isolate qi_intact = {
    property (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)
}

relation blocks_slices(S:nset, N:node)
# if set R blocks an intact node then R contains an intact node
axiom (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)

# the set of all intact nodes is a quorum
axiom exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)

object protocol = {
    
    relation voted_prepared(N:node, B:ballot, V:value)
    relation accepted_prepared(N:node, B:ballot, V:value)
    relation confirmed_prepared(N:node, B:ballot, V:value)
    relation voted_committed(N:node, B:ballot, V:value)
    relation accepted_committed(N:node, B:ballot, V:value)
    relation confirmed_committed(N:node, B:ballot, V:value)
    relation nomination_output(N:node, V:value)
    relation timer_armed(N:node)
    relation started(N:node, B:ballot)
    relation left_ballot(N:node, B:ballot)

    # messages received
    relation received_vote_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_prepare(N1:node, N2:node, B:ballot, V:value)
    relation received_vote_commit(N1:node, N2:node, B:ballot, V:value)
    relation received_accept_commit(N1:node, N2:node, B:ballot, V:value)

    object actions = {

        after init {
            voted_prepared(N,B,V) := false;
            accepted_prepared(N,B,V) := false;
            confirmed_prepared(N,B,V) := false;
            voted_committed(N,B,V) := false;
            accepted_committed(N,B,V) := false;
            confirmed_committed(N,B,V) := false;
            nomination_output(N,X) := false;
            left_ballot(N,B) := false;
            started(N,B) := false;
            timer_armed(N) := false;
            received_vote_prepare(N1,N2,B,V) := false;
            received_vote_commit(N1,N2,B,V) := false;
            received_accept_prepare(N1,N2,B,V) := false;
            received_accept_commit(N1,N2,B,V) := false;
            
            # here we add all intact nodes to the inital footpring; there are finitely many intact nodes, thus this is okay.
            l2s_d(N:node) := well_behaved(N); 
        }

        action assume_safety_properties = {
            # safety properties proved in SCP-safety.ivy that are necessary for this liveness proof.

            # messages received from well-behaved nodes are genuine:
            assume well_behaved(N) & received_accept_prepare(N,N2,B,V) & well_behaved(N2) -> accepted_prepared(N2,B,V);

            # if intact node n2 receives accept prepare (b1,v) from all intact nodes, then it confirms
            assume intact(n2) & (forall N. intact(N) -> received_accept_prepare(n2,N,b1,v)) -> confirmed_prepared(n2,b1,v);
            # if an intact node receives accept prepare (b1,v) from a blocking set, and accept (b1,v) is not contradicted, then the intact node also accepts (b1,v) as prepared:
            assume intact(N1) & blocks_slices(S,N1) & (forall N2. member(N2,S) -> received_accept_prepare(N1,N2,b1,v)) & (forall B,V . B < b1  & accepted_committed(N1,B,V) -> V = v) -> accepted_prepared(N1,b1,v);

            # if (B1,V1) is confirmed prepared by an intact node, then it cannot be contradicted:
            assume intact(N1) & confirmed_prepared(N1,B1,V1) & intact(N2) & B2 <= B1 & accepted_committed(N2,B2,V2) -> V1 = V2;

            # the cascade theorem: if a set of nodes including a quorum of an intact node accepts, then either all intact accept or there is an intact node blocked by a subset of intact that accepts:
            assume is_quorum(q0) & (exists N0 . intact(N0) & member(N0,q0)) & (forall N . intact(N) & member(N,q0) -> accepted_prepared(N,b1,v)) -> ((forall N1 . intact(N1) -> accepted_prepared(N1,b1,v)) | (exists N2,S . intact(N2) & ~accepted_prepared(N2,b1,v) & blocks_slices(S,N2) & (forall N3 . member(N3,S) -> (intact(N3) & accepted_prepared(N3,b1,v)))));
            
        }
        action timeout(n:node) = {
            call assume_safety_properties();
            
            assume timer_armed(n);
            local cur:ballot, suc:ballot {
                assume ~left_ballot(n, cur) & started(n, cur);
                assume  ~(cur < B & B < suc); # suc is the next ballot
                call change_ballot(n, suc);
            };
            
            call assume_safety_properties();
        }

        action join_ballot(n:node, b:ballot) = {
            call assume_safety_properties();
            
            assume ~left_ballot(n,b) & ~started(n,b);
            assume exists S . blocks_slices(S,n) & forall N . member(N,S) -> exists B,V . B >= b & (
                received_vote_prepare(n,N,B,V) | received_vote_commit(n,N,B,V) | received_accept_prepare(n,N,B,V) | received_accept_commit(n,N,B,V) );
            timer_armed(n) := false;
            call change_ballot(n,b);
            
            call assume_safety_properties();
        }

        action arm_timer(n:node) = {
            call assume_safety_properties();
            
            local cur:ballot {
                assume ~left_ballot(n, cur) & started(n, cur);
                assume exists Q . is_quorum(Q) & member(n,Q) & forall N . member(N, Q) -> exists V .
                    received_vote_prepare(n,N,cur,V) | received_vote_commit(n,N,cur,V) | received_accept_prepare(n,N,cur,V) | received_accept_commit(n,N,cur,V);
                timer_armed(n) := true;
            };
            
            call assume_safety_properties();
        }
        
        action change_ballot(n:node, b:ballot) = {
            call assume_safety_properties();
            
            assume ~left_ballot(n, b) & ~started(n, b);
            left_ballot(n,B) := B < b;
            started(n,b) := true;
            timer_armed(n) := false;
            # now vote prepared:
            local bmax:ballot, vmax:value {
                # use the highest confirmed prepared value or, if none exists, the nomination output:
                assume
                    ((forall B,V . B < b -> ~confirmed_prepared(n,B,V)) & nomination_output(n,vmax))
                    | (bmax < b & confirmed_prepared(n,bmax,vmax) & (forall B,V . B < b & confirmed_prepared(n,B,V) -> (B < bmax)));
                voted_prepared(n, b, vmax) := true; # Note we vote to prepare only once per ballot.
            };

            call assume_safety_properties();            
        }
        
        # n1 receives a new vote to prepare (b,v); it checks whether quorum threshold is reached and, if so, accepts (b,v) as prepared unless it accepted a different, earlier value as committed.
        action receive_vote_prepare(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();
            
            assume started(na,b);
            assume voted_prepared(nb,b,v);
            received_vote_prepare(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) &
               (forall B,V . ~(accepted_committed(na,B,V) & B < b & V ~= v)) & # not accepted anything contradictory
               (forall V . ~accepted_prepared(na,b,V)) # do not accept twice
            {
                accepted_prepared(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }

        action receive_accept_prepare(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();

            assume accepted_prepared(nb,b,v);
            received_accept_prepare(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_prepare(na,N,b,v) {
                confirmed_prepared(na,b,v) := true; # we must confirm prepared even if we left the ballot because that's used to pick the value to prepare in higher ballots.
                if ~left_ballot(na,b)  {
                    voted_committed(na,b,v) := true;
                };
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) & (forall N . member(N,Q) -> (received_vote_prepare(na,N,b,v) | received_accept_prepare(na,N,b,v)))) |
                   (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_prepare(na,N,b,v)))) &
                (forall B,V . ~(accepted_committed(na,B,V) & B < b & V ~= v)) & # not accepted anything contradictory
                (forall V . ~accepted_prepared(na,b,V)) # do not accept twice
            {
                accepted_prepared(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }

        action receive_vote_commit(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();            

            assume voted_committed(nb,b,v);
            received_vote_commit(na,nb,b,v) := true;
            if (exists Q . is_quorum(Q) & member(na,Q) &
                   (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) &
               (forall B,V . ~(accepted_prepared(na,B,V) & b < B & V ~= v)) & # not accepted anything contradictory
               (forall V . ~accepted_committed(na,b,V)) & # do not accept commit twice
               (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };

            call assume_safety_properties();
        }

        action receive_accept_commit(na:node, nb:node, b:ballot, v:value) = {
            call assume_safety_properties();

            assume accepted_committed(nb,b,v);
            received_accept_commit(na,nb,b,v) := true;
            if exists Q . is_quorum(Q) & member(na,Q) & forall N . member(N,Q) -> received_accept_commit(na,N,b,v) {
                confirmed_committed(na,b,v) := true;
            };
            if ((exists Q . is_quorum(Q) & member(na,Q) &
                    (forall N . member(N,Q) -> (received_vote_commit(na,N,b,v) | received_accept_commit(na,N,b,v)))) |
                (exists S . blocks_slices(S,na) & (forall N . member(N,S) -> received_accept_commit(na,N,b,v)))) &
                (forall B,V . ~(accepted_prepared(na,B,V) & b < B & V ~= v)) & # not accepted anything contradictory
                (forall V . ~accepted_committed(na,b,V)) & # do not accept twice.
                (confirmed_prepared(na,b,v)) # accept committed only if confirmed prepared. NOTE: otherwise befouled nodes have no link with the previous ballots since Byzantine node can make them accept anything.
            {
                accepted_committed(na,b,v) := true;
            };
            
            call assume_safety_properties();
        }
        
        action byzantine_step = {
            call assume_safety_properties();
            
            voted_prepared(N,B,X) := *;
            assume ~(well_behaved(N) & (voted_prepared(N,B,X) ~= old voted_prepared(N,B,X)));
            accepted_prepared(N,B,X) := *;
            assume ~(well_behaved(N) & (accepted_prepared(N,B,X) ~= old accepted_prepared(N,B,X)));
            voted_committed(N,B,X) := *;
            assume ~(well_behaved(N) & (voted_committed(N,B,X) ~= old voted_committed(N,B,X)));
            accepted_committed(N,B,X) := *;
            assume ~(well_behaved(N) & (accepted_committed(N,B,X) ~= old accepted_committed(N,B,X)));
            confirmed_prepared(N,B,V) := *;
            assume ~(well_behaved(N) & (confirmed_prepared(N,B,X) ~= old confirmed_prepared(N,B,X)));
            confirmed_committed(N,B,V) := *;
            assume ~(well_behaved(N) & (confirmed_committed(N,B,X) ~= old confirmed_committed(N,B,X)));
            nomination_output(N,V) := *;
            assume ~(well_behaved(N) & (nomination_output(N,X) ~= old nomination_output(N,X)));
            started(N,B) := *;
            assume ~(well_behaved(N) & (started(N,B) ~= old started(N,B)));
            left_ballot(N,B) := *;
            assume ~(well_behaved(N) & (left_ballot(N,B) ~= old left_ballot(N,B)));
            timer_armed(N) := *;
            assume ~(well_behaved(N) & (timer_armed(N) ~= old timer_armed(Nv)));
            received_vote_prepare(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_vote_prepare(N1,N2,B,V) ~= old received_vote_prepare(N1,N2,B,V)));
            received_accept_prepare(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_accept_prepare(N1,N2,B,V) ~= old received_accept_prepare(N1,N2,B,V)));
            received_vote_commit(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_vote_commit(N1,N2,B,V) ~= old received_vote_commit(N1,N2,B,V)));
            received_accept_commit(N1,N2,B,V) := *;
            assume ~(well_behaved(N1) & (received_accept_commit(N1,N2,B,V) ~= old received_accept_commit(N1,N2,B,V)));
            
            call assume_safety_properties();
        }
                 
        export receive_vote_prepare
        export byzantine_step
        export receive_vote_commit
        export receive_accept_prepare
        export receive_accept_commit
        export change_ballot
        export timeout
        export join_ballot
        export arm_timer
    }

    # Here we prove that by the end of a "good" ballot, all intact nodes have confirmed prepared the same things. This relies on the cascade theorem and also on the fact that once an intact node accepts something prepared, it can never be contradicted by other intact nodes anymore. This last property is crucial since nodes do not accept contradictory statements and therefore cascading may not occur.

    individual b0:ballot # the good ballot we consider
    
    # We assume that the n1 and n2 violate the property and we derive a contradiction.
    # Both n1 and n2 are intact, eventually n2 leave b0 without confirming (b1,v) as prepared while n1 confirms (b1,v) as prepared.
    individual n1:node
    individual n2:node
    individual b1:ballot
    individual v:value
    
    # prophecy witnesses:
    individual q0:nset
    
    # WARNING: due to quantifier alternation cycles, verification-time can vary a lot depending on the random seed passed to Z3 (could be e.g. 30 seconds vs 10 minutes).
         
    isolate liveness = {
        
        object spec = {
            temporal property (
                # b0 is synchronous for intact nodes: intact nodes receive all messages sent by well-behaved nodes that are in their quorums and blocking sets:
                (forall N1,N2,N3,V,B . intact(N1) & (well_behaved(N2) & (exists Q . is_quorum(Q) & member(N1,Q) & member(N2,Q)) | (exists S . blocks_slices(S,N1) & member(N2,S))) & intact(N3) & B <= b0 -> globally ~(left_ballot(N3,b0) & accepted_prepared(N2,B,V) & ~received_accept_prepare(N1,N2,B,V))) &
                # prophecy witness q0 (TODO here we take a shortcut whose soundness depends on the accepted_prepared relation being monotonic, which it obviously is):
                is_quorum(q0) & (exists N . intact(N) & member(N, q0)) & (globally ((exists Q . forall N . member(N,Q) & well_behaved(N) -> accepted_prepared(N,b1,v)) -> (forall N . member(N,q0) & well_behaved(N) -> accepted_prepared(N,b1,v)))) &
                b1 <= b0 & intact(n1) & intact(n2) & (eventually (confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)))
            ) -> false
        }

        object impl = {

            # The proof:
            # Once confirmed_prepared(n1,b1,v) holds, the quorum q0 has unanimously accepted (b1,v) as prepared. Hence, by the cascade theorem, either (a) all intact nodes accepted (b1,v) as prepared, or (b) there is an intact node n that has not accepted (b1,v) as prepared and that is blocked by the intact nodes that have. Note that (c) since b0 is a good ballot and n2 already left b0, all intact nodes received all accept-prepared messages addressed to them. In case (a), with (c), we get that all intact nodes received accept-prepare (b1,v) from a quorum and confirmed (b1,v) as prepared; thus ~confirmed_prepared(n2,b1,v) leads to a contradiction. In case (b), note that (b1,v) cannot be contradicted because n0 confirmed it prepared; thus node n must be waiting to receive an accept-prepare messages from another intact node, or otherwise it would have accepted (b1,v) as prepared. However, by (c) it must also have received them all; thus we reach a contradiction too.
            
            # properties of the initial footprint:
            conjecture well_behaved(N) -> l2s_d(N)
            conjecture l2s_d(n1) & l2s_d(n2) & l2s_d(b1) & l2s_d(v) & l2s_d(b0)

            conjecture  b1 <= b0 & intact(n1) & intact(n2)
           
            # waiting can only cease when the condition is true:
            conjecture ($l2s_w . confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)) -> ~(confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)) & eventually (confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))

            # the q0 witness:
            conjecture is_quorum(q0) & (exists N . intact(N) & member(N, q0)) & (globally ((exists Q . forall N . member(N,Q) & well_behaved(N) -> accepted_prepared(N,b1,v)) -> (forall N . member(N,q0) & well_behaved(N) -> accepted_prepared(N,b1,v))))
            conjecture confirmed_prepared(n1,b1,v) -> (forall N . member(N,q0) & intact(N) -> accepted_prepared(N,b1,v)) & is_quorum(q0) & (exists N2 . intact(N2) & member(N2,q0))
            
            # b0 is synchronous for intact nodes:
            conjecture intact(N1) & (well_behaved(N2) & (exists Q . is_quorum(Q) & member(N1,Q) & member(N2,Q)) | (exists S . blocks_slices(S,N1) & member(N2,S))) & intact(N3) & B <= b0 -> globally ~(left_ballot(N3,b0) & accepted_prepared(N2,B,V) & ~received_accept_prepare(N1,N2,B,V))

            # "confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v)" leads to a contradiction because, if "~confirmed_prepared(n2,b1,v)", then there must be an intact node that has not accepted (b1,v) as prepared, or otherwise n2 would have confirmed (b1,v) as prepared. Thus, because the intact members of q0 have accepted (b1,v) as prepared, by the cascaded theorem there is an intact node n blocked by a set of intact nodes that have accepted (b1,v) as prepared. But then n should have received all the messages from those intact nodes (since n2 left the ballot already), and thus, since (b1,v) is never contradicted, n must have accepted prepared (b1,v) too. This is a contradiction. Ivy does this reasoning automatically given the safety conjectures proved in SCP-safety.
            
            conjecture ~(confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))

            conjecture ($l2s_w . confirmed_prepared(n1,b1,v) & left_ballot(n2,b0) & ~confirmed_prepared(n2,b1,v))

            conjecture l2s_waiting # we never reach the freeze point.

        }
        
    } with actions, ordering_assms
}
